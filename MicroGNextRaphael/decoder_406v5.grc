options:
  parameters:
    author: rclar
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: no_gui
    hier_block_src_path: '.:'
    id: decoder_406v5
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: run
    sizing_mode: fixed
    thread_safe_setters: ''
    title: decoder_406v5
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8.0]
    rotation: 0
    state: enabled

blocks:
- name: carrier_frequency
  id: variable
  parameters:
    comment: ''
    value: '2000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 12.0]
    rotation: 0
    state: enabled
- name: cma_aa
  id: variable_adaptive_algorithm
  parameters:
    comment: ''
    cons: variable_constellation_rect_0
    delta: '10.0'
    ffactor: '0.99'
    modulus: '2'
    step_size: '.0001'
    type: cma
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1952, 4.0]
    rotation: 0
    state: enabled
- name: cma_aa_1
  id: variable_adaptive_algorithm
  parameters:
    comment: ''
    cons: digital.constellation_bpsk().base()
    delta: '10.0'
    ffactor: '0.99'
    modulus: '2'
    step_size: '.0001'
    type: cma
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 20.0]
    rotation: 0
    state: enabled
- name: damping_factor_0
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: d_f
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '0.1'
    stop: '4'
    value: '1'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1376, 8.0]
    rotation: 0
    state: disabled
- name: decim
  id: variable
  parameters:
    comment: ''
    value: '85'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1104, 12.0]
    rotation: 0
    state: enabled
- name: decim_taps
  id: variable_low_pass_filter_taps
  parameters:
    beta: '6.76'
    comment: ''
    cutoff_freq: samp_rate/decim
    gain: '1.0'
    samp_rate: samp_rate
    value: ''
    width: samp_rate/decim/8
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [912, 16.0]
    rotation: 0
    state: enabled
- name: loop_bandwidth_0
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: l_b
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '.0001'
    stop: '1'
    value: 2*math.pi*.04
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1200, 8.0]
    rotation: 0
    state: disabled
- name: rx_gain
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: rx_gain
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '1'
    stop: '70'
    value: '37'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [600, 16.0]
    rotation: 0
    state: disabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '680000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 12.0]
    rotation: 0
    state: enabled
- name: samples_per_bit
  id: variable
  parameters:
    comment: ''
    value: '1700'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [456, 12.0]
    rotation: 0
    state: enabled
- name: sps
  id: variable
  parameters:
    comment: ''
    value: '850'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1640, 4.0]
    rotation: 0
    state: enabled
- name: variable_constellation_rect_0
  id: variable_constellation_rect
  parameters:
    comment: ''
    const_points: '[-1, +1,]'
    imag_sect: '2'
    precision: '8'
    real_sect: '2'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1]'
    w_imag_sect: '1'
    w_real_sect: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1736, 4.0]
    rotation: 0
    state: enabled
- name: analog_const_source_x_0
  id: analog_const_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [216, 796.0]
    rotation: 0
    state: enabled
- name: analog_pwr_squelch_xx_0
  id: analog_pwr_squelch_xx
  parameters:
    affinity: ''
    alias: ''
    alpha: 1e-3
    comment: ''
    gate: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    ramp: '0'
    threshold: '-50'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 408.0]
    rotation: 0
    state: enabled
- name: blocks_tag_gate_0
  id: blocks_tag_gate
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    propagate_tags: 'False'
    single_key: '""'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [272, 428.0]
    rotation: 0
    state: enabled
- name: blocks_tagged_stream_align_0
  id: blocks_tagged_stream_align
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [896, 636.0]
    rotation: 0
    state: enabled
- name: blocks_tagged_stream_align_0_0
  id: blocks_tagged_stream_align
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1144, 780.0]
    rotation: 0
    state: enabled
- name: blocks_xor_xx_0
  id: blocks_xor_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [464, 784.0]
    rotation: 0
    state: enabled
- name: dc_blocker_xx_1
  id: dc_blocker_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    length: 8*sps
    long_form: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1512, 396.0]
    rotation: 0
    state: enabled
- name: digital_constellation_decoder_cb_0
  id: digital_constellation_decoder_cb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: variable_constellation_rect_0
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 636.0]
    rotation: 0
    state: enabled
- name: digital_correlate_access_code_tag_xx_0
  id: digital_correlate_access_code_tag_xx
  parameters:
    access_code: '010101100110101010'
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: '"packet_len"'
    threshold: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [448, 620.0]
    rotation: 0
    state: enabled
- name: digital_correlate_access_code_tag_xx_0_0
  id: digital_correlate_access_code_tag_xx
  parameters:
    access_code: '010101100110101010'
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: '"packet_len"'
    threshold: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [680, 764.0]
    rotation: 0
    state: enabled
- name: digital_costas_loop_cc_0_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: 'This is our costas loop that corrects the frequency offset

      coming from the imperfect receiver. This looks very

      close to our original signal now! All we need to do now

      is to sample the signal at the correct times

      in order to recover the symbols.'
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '2'
    use_snr: 'False'
    w: '.350'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [760, 424.0]
    rotation: 0
    state: enabled
- name: digital_linear_equalizer_0
  id: digital_linear_equalizer
  parameters:
    adapt_after_training: 'False'
    affinity: ''
    alg: cma_aa
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_taps: '15'
    sps: '2'
    training_sequence: '[ ]'
    training_start_tag: corr_est
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2056, 344.0]
    rotation: 0
    state: enabled
- name: digital_symbol_sync_xx_0_0
  id: digital_symbol_sync_xx
  parameters:
    affinity: ''
    alias: ''
    comment: 'Our symbol synchronization figures out the timing

      to sample the signal. After this samples the signal, you can

      see that we get back the original repeating

      [1, -1, -1, 1, -1, 1] sequence! However, we still need to convert

      the Manchester encoded symbols back into 1''s and 0''s.'
    constellation: digital.constellation_bpsk().base()
    damping: damping_factor_0
    loop_bw: loop_bandwidth_0
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    nfilters: '128'
    osps: '2'
    pfb_mf_taps: '[]'
    resamp_type: digital.IR_MMSE_8TAP
    sps: '850'
    ted_gain: '1.0'
    ted_type: digital.TED_ZERO_CROSSING
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1584, 308.0]
    rotation: 0
    state: disabled
- name: digital_symbol_sync_xx_0_0_0
  id: digital_symbol_sync_xx
  parameters:
    affinity: ''
    alias: ''
    comment: 'Our symbol synchronization figures out the timing

      to sample the signal. After this samples the signal, you can

      see that we get back the original repeating

      [1, -1, -1, 1, -1, 1] sequence! However, we still need to convert

      the Manchester encoded symbols back into 1''s and 0''s.'
    constellation: digital.constellation_bpsk().base()
    damping: '1'
    loop_bw: 2*math.pi*.04
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    nfilters: '128'
    osps: '2'
    pfb_mf_taps: '[]'
    resamp_type: digital.IR_MMSE_8TAP
    sps: '850'
    ted_gain: '1.0'
    ted_type: digital.TED_ZERO_CROSSING
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1584, 108.0]
    rotation: 0
    state: enabled
- name: iio_pluto_source_0
  id: iio_pluto_source
  parameters:
    affinity: ''
    alias: ''
    bandwidth: '200000 '
    bbdc: 'True'
    buffer_size: '32768'
    comment: ''
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: '406025000'
    fstop: '0'
    gain1: '''fast_attack'''
    len_tag_key: '""'
    manual_gain1: '37'
    maxoutbuf: '0'
    minoutbuf: '0'
    quadrature: 'True'
    rfdc: 'True'
    samplerate: samp_rate
    type: fc32
    uri: ip:192.168.4.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [24, 352.0]
    rotation: 0
    state: enabled
- name: import_0
  id: import
  parameters:
    alias: ''
    comment: ''
    imports: import math
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1520, 4.0]
    rotation: 0
    state: enabled
- name: interp_fir_filter_xxx_0
  id: interp_fir_filter_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    interp: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_delay: '0'
    taps: '[1/sps,] * int(sps)'
    type: ccc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1240, 396.0]
    rotation: 0
    state: enabled
- name: low_pass_filter_0
  id: low_pass_filter
  parameters:
    affinity: ''
    alias: ''
    beta: '6.76'
    comment: ''
    cutoff_freq: 10*samp_rate/sps
    decim: '1'
    gain: '1'
    interp: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate
    type: fir_filter_ccf
    width: 2*samp_rate/sps
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1032, 360.0]
    rotation: 0
    state: enabled
- name: network_tcp_sink_0
  id: network_tcp_sink
  parameters:
    addr: 127.0.0.1
    affinity: ''
    alias: ''
    comment: ''
    mode: '1'
    port: '5005'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1624, 620.0]
    rotation: 0
    state: enabled
- name: network_tcp_sink_0_0
  id: network_tcp_sink
  parameters:
    addr: 127.0.0.1
    affinity: ''
    alias: ''
    comment: ''
    mode: '1'
    port: '5006'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1624, 764.0]
    rotation: 0
    state: enabled
- name: packet_extractor
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\nfrom colorama\
      \ import Fore, Style, init\n\n# Initialize Colorama (for colored debug output\
      \ in console)\ninit(autoreset=True)\n\nclass ManchesterDecoderBlock(gr.basic_block):\n\
      \    def __init__(self, tag_name=\"packet_len\"):\n        gr.basic_block.__init__(\n\
      \            self,\n            name=\"ManchesterDecoder\",\n            in_sig=[np.uint8],\
      \   # input: stream of 8-bit (char) samples (0 or 1)\n            out_sig=[np.uint8]\
      \   # output: stream of 8-bit decoded bytes\n        )\n        self.tag_name\
      \ = pmt.intern(tag_name)\n        self.set_tag_propagation_policy(gr.TPP_DONT)\
      \   # handle tags manually&#8203;:contentReference[oaicite:6]{index=6}\n\n \
      \       # State for collecting packet bits\n        self._collecting = False\n\
      \        self._buffer = []       # buffer for Manchester bits of the current\
      \ packet\n        self._needed_bits = 0   # how many more bits are needed to\
      \ complete current packet\n\n        # Ensure output buffer can accommodate\
      \ full packets (15 bytes)\n        self.set_output_multiple(15)\n\n    def forecast(self,\
      \ noutput_items, ninput_items):\n        \"\"\"\n        Tell GR how many input\
      \ items are required on each input port\n        to produce noutput_items on\
      \ the output port.\n\n        Since we only ever want to process full 240\u2010\
      sample bursts:\n          - If we\u2019re not currently collecting a packet,\
      \ we need 240 samples\n          - If we\u2019re mid\u2010packet, we need however\
      \ many bits remain\n        \"\"\"\n        if self._collecting:\n         \
      \   # we\u2019re in the middle of gathering a packet:\n            needed =\
      \ self._needed_bits\n        else:\n            # waiting for a new packet start\
      \ \u2192 need full burst\n            needed = 240\n\n        # return a tuple\
      \ (one entry per input port)\n        return (needed,)\n\n\n    def general_work(self,\
      \ input_items, output_items):\n        in0 = input_items[0]\n        out0 =\
      \ output_items[0]\n        n_in = len(in0)\n\n        # If not currently in\
      \ a packet, look for a 'packet_len' tag to start a new burst\n        if not\
      \ self._collecting:\n            # No ongoing packet, search for the start tag\
      \ in this input window\n            tags = self.get_tags_in_window(0, 0, n_in,\
      \ self.tag_name)\n            if len(tags) == 0:\n                # No packet\
      \ start tag found in this chunk\n                if n_in > 0:\n            \
      \        # print(Fore.YELLOW + f\"No packet tag found in {n_in} samples \u2013\
      \ dropping them.\" + Style.RESET_ALL)\n                    self.consume(0, n_in)\
      \  # discard irrelevant samples\n                return 0  # no output produced\n\
      \n            # We found at least one tag; consider the first tag as start of\
      \ a new packet\n            tags.sort(key=lambda t: t.offset)\n            tag\
      \ = tags[0]\n            tag_offset = tag.offset - self.nitems_read(0)  # relative\
      \ index of tag in the buffer&#8203;:contentReference[oaicite:7]{index=7}\n \
      \           if tag_offset > 0:\n                # Skip any samples preceding\
      \ the tag (shouldn't contain valid data)\n                # print(Fore.MAGENTA\
      \ + f\"Skipping {tag_offset} pre-tag sample(s) (noise/preamble).\" + Style.RESET_ALL)\n\
      \                self.consume(0, tag_offset)\n                # Adjust input\
      \ array to start at the tag position\n                in0 = in0[tag_offset:]\n\
      \                n_in -= tag_offset\n                tag_offset = 0\n\n    \
      \        # Initialize a new packet collection\n            self._collecting\
      \ = True\n            # Determine expected packet length from tag (should be\
      \ 240)\n            pkt_len = pmt.to_python(tag.value)\n            if isinstance(pkt_len,\
      \ (list, tuple)):  # safety: convert PMT vector or u64 to int\n            \
      \    pkt_len = int(pkt_len[0] if pkt_len else 0)\n            else:\n      \
      \          pkt_len = int(pkt_len)\n            expected_bits = pkt_len\n   \
      \         if expected_bits != 240:\n                # Log a warning if the tag\
      \ length is not the expected 240\n                print(Fore.YELLOW + f\"Warning:\
      \ tag indicates {expected_bits} bits (expected 240).\" + Style.RESET_ALL)\n\
      \            self._needed_bits = expected_bits\n            self._buffer = []\n\
      \            print(Fore.CYAN + f\"Packet start detected (tag at input 0). Expecting\
      \ {expected_bits} Manchester bits...\" + Style.RESET_ALL)\n\n            # Process\
      \ available bits in this call for the new packet\n            if n_in >= self._needed_bits:\n\
      \                # We have the entire 240-bit burst in this chunk\n        \
      \        needed = self._needed_bits\n                bits_chunk = in0[:needed]\n\
      \                self._buffer.extend(bits_chunk.tolist())\n                print(Fore.CYAN\
      \ + f\"Collected all {needed} bits for packet, decoding...\" + Style.RESET_ALL)\n\
      \                self._decode_and_output_packet(out0)  # decode and write output\
      \ bytes\n                # Consume the 240 input bits used for this packet\n\
      \                self.consume(0, needed)\n                # (If there are extra\
      \ bits beyond this packet in 'in0', leave them for the next call)\n        \
      \        return len(out0[:15])  # produced 15 bytes (or 0 if decode failed)\n\
      \            else:\n                # Only a partial burst is available; buffer\
      \ it and wait for more\n                self._buffer.extend(in0.tolist())\n\
      \                self._needed_bits -= n_in\n                print(Fore.CYAN\
      \ + f\"Collected {n_in} bits (partial packet). Waiting for {self._needed_bits}\
      \ more bits...\" + Style.RESET_ALL)\n                self.consume(0, n_in) \
      \ # consume all available input\n                # No output yet (packet not\
      \ complete)\n                return 0\n\n        else:\n            # We are\
      \ in the middle of gathering a packet (a previous tag was seen)\n          \
      \  if n_in == 0:\n                return 0  # nothing to do\n\n            if\
      \ n_in >= self._needed_bits:\n                # This chunk provides the remaining\
      \ bits to finish the packet\n                needed = self._needed_bits\n  \
      \              bits_chunk = in0[:needed]\n                self._buffer.extend(bits_chunk.tolist())\n\
      \                print(Fore.CYAN + f\"Received final {needed} bits, packet complete.\
      \ Decoding...\" + Style.RESET_ALL)\n                self._decode_and_output_packet(out0)\n\
      \                self.consume(0, needed)  # consume only the bits used for this\
      \ packet\n                return len(out0[:15])  # 15 bytes output (or 0 if\
      \ decode failed)\n            else:\n                # Still not enough to finish;\
      \ accumulate and continue waiting\n                self._buffer.extend(in0.tolist())\n\
      \                self._needed_bits -= n_in\n                print(Fore.CYAN\
      \ + f\"Received {n_in} more bits (total collected {len(self._buffer)}). Still\
      \ need {self._needed_bits} bits...\" + Style.RESET_ALL)\n                self.consume(0,\
      \ n_in)\n                return 0\n\n    def _decode_and_output_packet(self,\
      \ out_buffer):\n        \"\"\"\n        Decode the 240-bit Manchester buffer\
      \ into 15 bytes and output to out_buffer.\n        Attaches an output tag and\
      \ prints debug info. If decode fails, drops packet.\n        \"\"\"\n      \
      \  # We expect exactly 240 bits in the buffer when called\n        bits = self._buffer\n\
      \        self._collecting = False   # reset state for next packet\n        self._needed_bits\
      \ = 0\n\n        if len(bits) != 240:\n            # Safety check (should not\
      \ happen if logic is correct)\n            print(Fore.RED + f\"Error: Collected\
      \ {len(bits)} bits, expected 240. Dropping packet.\" + Style.RESET_ALL)\n  \
      \          self._buffer = []\n            return\n\n        # Manchester decode:\
      \ map (0,1)->0 and (1,0)->1\n                # Manchester decode with \u201C\
      flatten\u2010to\u20100\u201D on invalid pairs\n        decoded_bits = []\n \
      \       for i in range(0, 240, 2):\n            b0 = bits[i]\n            b1\
      \ = bits[i+1]\n            if (b0, b1) == (0, 1):\n                decoded_bits.append(0)\n\
      \            elif (b0, b1) == (1, 0):\n                decoded_bits.append(1)\n\
      \            else:\n                # Invalid pair: flatten to 0 and keep going\n\
      \                decoded_bits.append(0)\n                # print(Fore.YELLOW\
      \ + f\"[MD][WARN] Invalid pair at {i}:({b0},{b1}), flattened to 0.\" + Style.RESET_ALL)\n\
      \n\n        # Clear buffer for next packet regardless of outcome\n        self._buffer\
      \ = []\n\n\n        # Pack 120 decoded bits into 15 bytes (MSB-first in each\
      \ byte)\n        decoded_bytes = []\n        for j in range(0, 120, 8):\n  \
      \          byte_val = 0\n            for bit in decoded_bits[j:j+8]:\n     \
      \           byte_val = (byte_val << 1) | bit\n            decoded_bytes.append(byte_val)\n\
      \        decoded_bytes = np.array(decoded_bytes, dtype=np.uint8)  # 15-byte\
      \ array\n\n        # Add a 'packet_len' tag to mark this 15-byte packet on output&#8203;:contentReference[oaicite:8]{index=8}\n\
      \        self.add_item_tag(\n            0, \n            self.nitems_written(0),\
      \             # absolute position of first output byte\n            self.tag_name,\
      \ \n            pmt.from_long(len(decoded_bytes))   # value = 15\n        )\n\
      \        # Output the decoded bytes\n        out_buffer[:len(decoded_bytes)]\
      \ = decoded_bytes\n        # Debug output of the decoded payload\n        print(Fore.GREEN\
      \ + f\"Decoded Standard packet -> {len(decoded_bits)} bits into {len(decoded_bytes)}\
      \ bytes: \" \n              + ' '.join(f'0x{b:02X}' for b in decoded_bytes)\
      \ + Style.RESET_ALL)\n        print(Fore.GREEN + f\"Emitted packet of {len(decoded_bytes)}\
      \ byte(s).\\n\" + Style.RESET_ALL)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag_name: '"packet_len"'
  states:
    _io_cache: ('ManchesterDecoder', 'ManchesterDecoderBlock', [('tag_name', "'packet_len'")],
      [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['tag_name'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1152, 636.0]
    rotation: 0
    state: enabled
- name: packet_extractor_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\nfrom colorama\
      \ import Fore, Style, init\n\n# Initialize Colorama (for colored debug output\
      \ in console)\ninit(autoreset=True)\n\nclass ManchesterDecoderBlock(gr.basic_block):\n\
      \    def __init__(self, tag_name=\"packet_len\"):\n        gr.basic_block.__init__(\n\
      \            self,\n            name=\"ManchesterDecoder\",\n            in_sig=[np.uint8],\
      \   # input: stream of 8-bit (char) samples (0 or 1)\n            out_sig=[np.uint8]\
      \   # output: stream of 8-bit decoded bytes\n        )\n        self.tag_name\
      \ = pmt.intern(tag_name)\n        self.set_tag_propagation_policy(gr.TPP_DONT)\
      \   # handle tags manually&#8203;:contentReference[oaicite:6]{index=6}\n\n \
      \       # State for collecting packet bits\n        self._collecting = False\n\
      \        self._buffer = []       # buffer for Manchester bits of the current\
      \ packet\n        self._needed_bits = 0   # how many more bits are needed to\
      \ complete current packet\n\n        # Ensure output buffer can accommodate\
      \ full packets (15 bytes)\n        self.set_output_multiple(15)\n\n    def forecast(self,\
      \ noutput_items, ninput_items):\n        \"\"\"\n        Tell GR how many input\
      \ items are required on each input port\n        to produce noutput_items on\
      \ the output port.\n\n        Since we only ever want to process full 240\u2010\
      sample bursts:\n          - If we\u2019re not currently collecting a packet,\
      \ we need 240 samples\n          - If we\u2019re mid\u2010packet, we need however\
      \ many bits remain\n        \"\"\"\n        if self._collecting:\n         \
      \   # we\u2019re in the middle of gathering a packet:\n            needed =\
      \ self._needed_bits\n        else:\n            # waiting for a new packet start\
      \ \u2192 need full burst\n            needed = 240\n\n        # return a tuple\
      \ (one entry per input port)\n        return (needed,)\n\n\n    def general_work(self,\
      \ input_items, output_items):\n        in0 = input_items[0]\n        out0 =\
      \ output_items[0]\n        n_in = len(in0)\n\n        # If not currently in\
      \ a packet, look for a 'packet_len' tag to start a new burst\n        if not\
      \ self._collecting:\n            # No ongoing packet, search for the start tag\
      \ in this input window\n            tags = self.get_tags_in_window(0, 0, n_in,\
      \ self.tag_name)\n            if len(tags) == 0:\n                # No packet\
      \ start tag found in this chunk\n                if n_in > 0:\n            \
      \        # print(Fore.YELLOW + f\"No packet tag found in {n_in} samples \u2013\
      \ dropping them.\" + Style.RESET_ALL)\n                    self.consume(0, n_in)\
      \  # discard irrelevant samples\n                return 0  # no output produced\n\
      \n            # We found at least one tag; consider the first tag as start of\
      \ a new packet\n            tags.sort(key=lambda t: t.offset)\n            tag\
      \ = tags[0]\n            tag_offset = tag.offset - self.nitems_read(0)  # relative\
      \ index of tag in the buffer&#8203;:contentReference[oaicite:7]{index=7}\n \
      \           if tag_offset > 0:\n                # Skip any samples preceding\
      \ the tag (shouldn't contain valid data)\n                print(Fore.MAGENTA\
      \ + f\"Skipping {tag_offset} pre-tag sample(s) (noise/preamble).\" + Style.RESET_ALL)\n\
      \                self.consume(0, tag_offset)\n                # Adjust input\
      \ array to start at the tag position\n                in0 = in0[tag_offset:]\n\
      \                n_in -= tag_offset\n                tag_offset = 0\n\n    \
      \        # Initialize a new packet collection\n            self._collecting\
      \ = True\n            # Determine expected packet length from tag (should be\
      \ 240)\n            pkt_len = pmt.to_python(tag.value)\n            if isinstance(pkt_len,\
      \ (list, tuple)):  # safety: convert PMT vector or u64 to int\n            \
      \    pkt_len = int(pkt_len[0] if pkt_len else 0)\n            else:\n      \
      \          pkt_len = int(pkt_len)\n            expected_bits = pkt_len\n   \
      \         if expected_bits != 240:\n                # Log a warning if the tag\
      \ length is not the expected 240\n                print(Fore.YELLOW + f\"Warning:\
      \ tag indicates {expected_bits} bits (expected 240).\" + Style.RESET_ALL)\n\
      \            self._needed_bits = expected_bits\n            self._buffer = []\n\
      \            print(Fore.CYAN + f\"Packet start detected (tag at input 0). Expecting\
      \ {expected_bits} Manchester bits...\" + Style.RESET_ALL)\n\n            # Process\
      \ available bits in this call for the new packet\n            if n_in >= self._needed_bits:\n\
      \                # We have the entire 240-bit burst in this chunk\n        \
      \        needed = self._needed_bits\n                bits_chunk = in0[:needed]\n\
      \                self._buffer.extend(bits_chunk.tolist())\n                print(Fore.CYAN\
      \ + f\"Collected all {needed} bits for packet, decoding...\" + Style.RESET_ALL)\n\
      \                self._decode_and_output_packet(out0)  # decode and write output\
      \ bytes\n                # Consume the 240 input bits used for this packet\n\
      \                self.consume(0, needed)\n                # (If there are extra\
      \ bits beyond this packet in 'in0', leave them for the next call)\n        \
      \        return len(out0[:15])  # produced 15 bytes (or 0 if decode failed)\n\
      \            else:\n                # Only a partial burst is available; buffer\
      \ it and wait for more\n                self._buffer.extend(in0.tolist())\n\
      \                self._needed_bits -= n_in\n                print(Fore.CYAN\
      \ + f\"Collected {n_in} bits (partial packet). Waiting for {self._needed_bits}\
      \ more bits...\" + Style.RESET_ALL)\n                self.consume(0, n_in) \
      \ # consume all available input\n                # No output yet (packet not\
      \ complete)\n                return 0\n\n        else:\n            # We are\
      \ in the middle of gathering a packet (a previous tag was seen)\n          \
      \  if n_in == 0:\n                return 0  # nothing to do\n\n            if\
      \ n_in >= self._needed_bits:\n                # This chunk provides the remaining\
      \ bits to finish the packet\n                needed = self._needed_bits\n  \
      \              bits_chunk = in0[:needed]\n                self._buffer.extend(bits_chunk.tolist())\n\
      \                print(Fore.CYAN + f\"Received final {needed} bits, packet complete.\
      \ Decoding...\" + Style.RESET_ALL)\n                self._decode_and_output_packet(out0)\n\
      \                self.consume(0, needed)  # consume only the bits used for this\
      \ packet\n                return len(out0[:15])  # 15 bytes output (or 0 if\
      \ decode failed)\n            else:\n                # Still not enough to finish;\
      \ accumulate and continue waiting\n                self._buffer.extend(in0.tolist())\n\
      \                self._needed_bits -= n_in\n                print(Fore.CYAN\
      \ + f\"Received {n_in} more bits (total collected {len(self._buffer)}). Still\
      \ need {self._needed_bits} bits...\" + Style.RESET_ALL)\n                self.consume(0,\
      \ n_in)\n                return 0\n\n    def _decode_and_output_packet(self,\
      \ out_buffer):\n        \"\"\"\n        Decode the 240-bit Manchester buffer\
      \ into 15 bytes and output to out_buffer.\n        Attaches an output tag and\
      \ prints debug info. If decode fails, drops packet.\n        \"\"\"\n      \
      \  # We expect exactly 240 bits in the buffer when called\n        bits = self._buffer\n\
      \        self._collecting = False   # reset state for next packet\n        self._needed_bits\
      \ = 0\n\n        if len(bits) != 240:\n            # Safety check (should not\
      \ happen if logic is correct)\n            print(Fore.RED + f\"Error: Collected\
      \ {len(bits)} bits, expected 240. Dropping packet.\" + Style.RESET_ALL)\n  \
      \          self._buffer = []\n            return\n\n        # Manchester decode:\
      \ map (0,1)->0 and (1,0)->1\n                # Manchester decode with \u201C\
      flatten\u2010to\u20100\u201D on invalid pairs\n        decoded_bits = []\n \
      \       for i in range(0, 240, 2):\n            b0 = bits[i]\n            b1\
      \ = bits[i+1]\n            if (b0, b1) == (0, 1):\n                decoded_bits.append(0)\n\
      \            elif (b0, b1) == (1, 0):\n                decoded_bits.append(1)\n\
      \            else:\n                # Invalid pair: flatten to 0 and keep going\n\
      \                decoded_bits.append(0)\n                # print(Fore.YELLOW\
      \ + f\"[MD][WARN] Invalid pair at {i}:({b0},{b1}), flattened to 0.\" + Style.RESET_ALL)\n\
      \n\n        # Clear buffer for next packet regardless of outcome\n        self._buffer\
      \ = []\n\n\n        # Pack 120 decoded bits into 15 bytes (MSB-first in each\
      \ byte)\n        decoded_bytes = []\n        for j in range(0, 120, 8):\n  \
      \          byte_val = 0\n            for bit in decoded_bits[j:j+8]:\n     \
      \           byte_val = (byte_val << 1) | bit\n            decoded_bytes.append(byte_val)\n\
      \        decoded_bytes = np.array(decoded_bytes, dtype=np.uint8)  # 15-byte\
      \ array\n\n        # Add a 'packet_len' tag to mark this 15-byte packet on output&#8203;:contentReference[oaicite:8]{index=8}\n\
      \        self.add_item_tag(\n            0, \n            self.nitems_written(0),\
      \             # absolute position of first output byte\n            self.tag_name,\
      \ \n            pmt.from_long(len(decoded_bytes))   # value = 15\n        )\n\
      \        # Output the decoded bytes\n        out_buffer[:len(decoded_bytes)]\
      \ = decoded_bytes\n        # Debug output of the decoded payload\n        print(Fore.GREEN\
      \ + f\"Decoded Inverted packet -> {len(decoded_bits)} bits into {len(decoded_bytes)}\
      \ bytes: \" \n              + ' '.join(f'0x{b:02X}' for b in decoded_bytes)\
      \ + Style.RESET_ALL)\n        print(Fore.GREEN + f\"Emitted packet of {len(decoded_bytes)}\
      \ byte(s).\\n\" + Style.RESET_ALL)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag_name: '"packet_len"'
  states:
    _io_cache: ('ManchesterDecoder', 'ManchesterDecoderBlock', [('tag_name', "'packet_len'")],
      [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['tag_name'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1392, 780.0]
    rotation: 0
    state: enabled
- name: qtgui_const_sink_x_2_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: 3,1,1,1
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"Received Constellation"'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 300.0]
    rotation: 0
    state: disabled
- name: qtgui_const_sink_x_2_0_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: 4,1,1,1
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"Match Filtered Constellation"'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [760, 324.0]
    rotation: 0
    state: disabled
- name: qtgui_const_sink_x_2_0_0_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: 6,1,1,1
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"Sampled Constellation"'
    nconnections: '1'
    size: '50'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2320, 220.0]
    rotation: 0
    state: disabled
- name: qtgui_const_sink_x_2_0_0_0_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: 5,1,1,1
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"Post Costas Loop Constellation"'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1512, 484.0]
    rotation: 0
    state: disabled
- name: qtgui_sink_x_0
  id: qtgui_sink_x
  parameters:
    affinity: ''
    alias: ''
    bw: samp_rate
    comment: ''
    fc: '0'
    fftsize: '1024'
    gui_hint: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '""'
    plotconst: 'True'
    plotfreq: 'True'
    plottime: 'True'
    plotwaterfall: 'True'
    rate: '10'
    showports: 'False'
    showrf: 'False'
    type: complex
    wintype: window.WIN_BLACKMAN_hARRIS
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1512, 128.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_0_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 3,0,1,1
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Received Signal"'
    nconnections: '1'
    size: '8192'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 168.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_0_0_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 4,0,1,1
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Match Filtered Signal"'
    nconnections: '1'
    size: '8192'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [760, 200.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_2
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'True'
    entags: 'True'
    grid: 'False'
    gui_hint: 6,0,1,1
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '0'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Sampled Manchester Symbols"'
    nconnections: '1'
    size: '512'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2320, 88.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_2_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 5,0,1,1
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Post Costas Loop Signal"'
    nconnections: '1'
    size: '8192'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1512, 272.0]
    rotation: 0
    state: disabled
- name: tag_setter
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n#\n# TagRewriter.py\n# Simply copies the\
      \ stream and rewrites any \u2018packet_len\u2019 tag to value=240.\n\nimport\
      \ numpy as np\nfrom gnuradio import gr\nimport pmt\n\nclass TagRewriter(gr.basic_block):\n\
      \    def __init__(self, tag_key=\"packet_len\", new_len=240):\n        gr.basic_block.__init__(\n\
      \            self,\n            name=\"TagRewriter\",\n            in_sig =[np.int8],\
      \    # 1\u2010byte symbols in\n            out_sig=[np.int8]     # 1\u2010byte\
      \ symbols out\n        )\n        self.key     = pmt.intern(tag_key)\n     \
      \   self.new_val = pmt.from_long(int(new_len))\n        # disable auto\u2010\
      forward of tags\n        self.set_tag_propagation_policy(gr.TPP_DONT)\n\n  \
      \  def forecast(self, noutput_items, ninput_items):\n        # request equal\
      \ number of inputs for outputs\n        return (noutput_items,)\n\n    def general_work(self,\
      \ input_items, output_items):\n        in0  = input_items[0]\n        out0 =\
      \ output_items[0]\n        # only process as many as both buffers allow\n  \
      \      n = min(len(in0), len(out0))\n        if n == 0:\n            return\
      \ 0\n\n        # 1) copy samples one-by-one (avoids shape-broadcast errors)\n\
      \        for i in range(n):\n            out0[i] = in0[i]\n\n        # 2) find\
      \ any 'packet_len' tags in this window [0..n)\n        tags = self.get_tags_in_window(0,\
      \ 0, n)\n        for t in tags:\n            if t.key == self.key:\n       \
      \         # relative offset from start of this window\n                rel_off\
      \ = int(t.offset - self.nitems_read(0))\n                # absolute offset in\
      \ output stream\n                abs_off = self.nitems_written(0) + rel_off\n\
      \                # re-add the same tag but with value=new_len\n            \
      \    self.add_item_tag(0, abs_off, self.key, self.new_val)\n\n        # 3) consume\
      \ & produce\n        self.consume(0, n)\n        return n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    new_len: '240'
    tag_key: '"packet_len"'
  states:
    _io_cache: ('TagRewriter', 'TagRewriter', [('tag_key', "'packet_len'"), ('new_len',
      '240')], [('0', 'byte', 1)], [('0', 'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [688, 628.0]
    rotation: 0
    state: enabled
- name: tag_setter_0
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n#\n# TagRewriter.py\n# Simply copies the\
      \ stream and rewrites any \u2018packet_len\u2019 tag to value=240.\n\nimport\
      \ numpy as np\nfrom gnuradio import gr\nimport pmt\n\nclass TagRewriter(gr.basic_block):\n\
      \    def __init__(self, tag_key=\"packet_len\", new_len=240):\n        gr.basic_block.__init__(\n\
      \            self,\n            name=\"TagRewriter\",\n            in_sig =[np.int8],\
      \    # 1\u2010byte symbols in\n            out_sig=[np.int8]     # 1\u2010byte\
      \ symbols out\n        )\n        self.key     = pmt.intern(tag_key)\n     \
      \   self.new_val = pmt.from_long(int(new_len))\n        # disable auto\u2010\
      forward of tags\n        self.set_tag_propagation_policy(gr.TPP_DONT)\n\n  \
      \  def forecast(self, noutput_items, ninput_items):\n        # request equal\
      \ number of inputs for outputs\n        return (noutput_items,)\n\n    def general_work(self,\
      \ input_items, output_items):\n        in0  = input_items[0]\n        out0 =\
      \ output_items[0]\n        # only process as many as both buffers allow\n  \
      \      n = min(len(in0), len(out0))\n        if n == 0:\n            return\
      \ 0\n\n        # 1) copy samples one-by-one (avoids shape-broadcast errors)\n\
      \        for i in range(n):\n            out0[i] = in0[i]\n\n        # 2) find\
      \ any 'packet_len' tags in this window [0..n)\n        tags = self.get_tags_in_window(0,\
      \ 0, n)\n        for t in tags:\n            if t.key == self.key:\n       \
      \         # relative offset from start of this window\n                rel_off\
      \ = int(t.offset - self.nitems_read(0))\n                # absolute offset in\
      \ output stream\n                abs_off = self.nitems_written(0) + rel_off\n\
      \                # re-add the same tag but with value=new_len\n            \
      \    self.add_item_tag(0, abs_off, self.key, self.new_val)\n\n        # 3) consume\
      \ & produce\n        self.consume(0, n)\n        return n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    new_len: '240'
    tag_key: '"packet_len"'
  states:
    _io_cache: ('TagRewriter', 'TagRewriter', [('tag_key', "'packet_len'"), ('new_len',
      '240')], [('0', 'byte', 1)], [('0', 'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [944, 772.0]
    rotation: 0
    state: enabled
- name: virtual_sink_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: vsource
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2320, 324.0]
    rotation: 0
    state: enabled
- name: virtual_source_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: vsource
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [24, 636.0]
    rotation: 0
    state: enabled

connections:
- [analog_const_source_x_0, '0', blocks_xor_xx_0, '1']
- [analog_pwr_squelch_xx_0, '0', digital_costas_loop_cc_0_0, '0']
- [analog_pwr_squelch_xx_0, '0', qtgui_const_sink_x_2_0_0, '0']
- [analog_pwr_squelch_xx_0, '0', qtgui_time_sink_x_0_0_0_0, '0']
- [blocks_tag_gate_0, '0', analog_pwr_squelch_xx_0, '0']
- [blocks_tag_gate_0, '0', qtgui_const_sink_x_2_0, '0']
- [blocks_tag_gate_0, '0', qtgui_time_sink_x_0_0_0, '0']
- [blocks_tagged_stream_align_0, '0', packet_extractor, '0']
- [blocks_tagged_stream_align_0_0, '0', packet_extractor_0, '0']
- [blocks_xor_xx_0, '0', digital_correlate_access_code_tag_xx_0_0, '0']
- [dc_blocker_xx_1, '0', digital_symbol_sync_xx_0_0, '0']
- [dc_blocker_xx_1, '0', digital_symbol_sync_xx_0_0_0, '0']
- [digital_constellation_decoder_cb_0, '0', blocks_file_sink_0, '0']
- [digital_constellation_decoder_cb_0, '0', blocks_xor_xx_0, '0']
- [digital_constellation_decoder_cb_0, '0', digital_correlate_access_code_tag_xx_0,
  '0']
- [digital_correlate_access_code_tag_xx_0, '0', tag_setter, '0']
- [digital_correlate_access_code_tag_xx_0_0, '0', tag_setter_0, '0']
- [digital_costas_loop_cc_0_0, '0', low_pass_filter_0, '0']
- [digital_linear_equalizer_0, '0', qtgui_const_sink_x_2_0_0_0, '0']
- [digital_linear_equalizer_0, '0', qtgui_time_sink_x_2, '0']
- [digital_linear_equalizer_0, '0', virtual_sink_0, '0']
- [digital_symbol_sync_xx_0_0, '0', digital_linear_equalizer_0, '0']
- [digital_symbol_sync_xx_0_0_0, '0', digital_linear_equalizer_0, '0']
- [iio_pluto_source_0, '0', blocks_tag_gate_0, '0']
- [interp_fir_filter_xxx_0, '0', dc_blocker_xx_1, '0']
- [interp_fir_filter_xxx_0, '0', qtgui_const_sink_x_2_0_0_0_0, '0']
- [interp_fir_filter_xxx_0, '0', qtgui_sink_x_0, '0']
- [interp_fir_filter_xxx_0, '0', qtgui_time_sink_x_2_0, '0']
- [low_pass_filter_0, '0', interp_fir_filter_xxx_0, '0']
- [packet_extractor, '0', network_tcp_sink_0, '0']
- [packet_extractor_0, '0', network_tcp_sink_0_0, '0']
- [tag_setter, '0', blocks_tagged_stream_align_0, '0']
- [tag_setter_0, '0', blocks_tagged_stream_align_0_0, '0']
- [virtual_source_0, '0', digital_constellation_decoder_cb_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.12.0
